{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/SimpleDEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title SimpleDEX\n * @notice A simplified decentralized exchange using constant product AMM (x * y = k)\n * @dev Supports a single token pair with add/remove liquidity and swap functions\n */\ncontract SimpleDEX is ReentrancyGuard {\n\t// Token addresses\n\tIERC20 public immutable tokenA;\n\tIERC20 public immutable tokenB;\n\n\t// Pool reserves\n\tuint256 public reserveA;\n\tuint256 public reserveB;\n\n\t// Liquidity tracking\n\tuint256 public totalLiquidity;\n\tmapping(address => uint256) public liquidity;\n\n\t// Fee (0.3% = 3/1000)\n\tuint256 public constant FEE_NUMERATOR = 3;\n\tuint256 public constant FEE_DENOMINATOR = 1000;\n\n\t// Events\n\tevent LiquidityAdded(\n\t\taddress indexed provider,\n\t\tuint256 amountA,\n\t\tuint256 amountB,\n\t\tuint256 liquidityMinted\n\t);\n\tevent LiquidityRemoved(\n\t\taddress indexed provider,\n\t\tuint256 amountA,\n\t\tuint256 amountB,\n\t\tuint256 liquidityBurned\n\t);\n\tevent Swap(\n\t\taddress indexed user,\n\t\taddress indexed tokenIn,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut\n\t);\n\n\t/**\n\t * @notice Constructor sets the token pair\n\t * @param _tokenA Address of first token\n\t * @param _tokenB Address of second token\n\t */\n\tconstructor(address _tokenA, address _tokenB) {\n\t\trequire(\n\t\t\t_tokenA != address(0) && _tokenB != address(0),\n\t\t\t\"Invalid token address\"\n\t\t);\n\t\trequire(_tokenA != _tokenB, \"Tokens must be different\");\n\n\t\ttokenA = IERC20(_tokenA);\n\t\ttokenB = IERC20(_tokenB);\n\t}\n\n\t/**\n\t * @notice Add liquidity to the pool\n\t * @param amountA Amount of token A to add\n\t * @param amountB Amount of token B to add\n\t * @return liquidityMinted Amount of liquidity shares minted\n\t */\n\tfunction addLiquidity(\n\t\tuint256 amountA,\n\t\tuint256 amountB\n\t) external nonReentrant returns (uint256 liquidityMinted) {\n\t\trequire(amountA > 0 && amountB > 0, \"Amounts must be greater than 0\");\n\n\t\t// Transfer tokens from user to contract\n\t\ttokenA.transferFrom(msg.sender, address(this), amountA);\n\t\ttokenB.transferFrom(msg.sender, address(this), amountB);\n\n\t\t// Calculate liquidity to mint\n\t\tif (totalLiquidity == 0) {\n\t\t\t// First liquidity provider: liquidity = sqrt(amountA * amountB)\n\t\t\t// We use a simple formula: liquidity = amountA (for simplicity)\n\t\t\tliquidityMinted = amountA;\n\t\t} else {\n\t\t\t// Subsequent liquidity: maintain pool ratio\n\t\t\t// liquidityMinted = (amountA / reserveA) * totalLiquidity\n\t\t\t// We take the minimum to prevent manipulation\n\t\t\tuint256 liquidityA = (amountA * totalLiquidity) / reserveA;\n\t\t\tuint256 liquidityB = (amountB * totalLiquidity) / reserveB;\n\t\t\tliquidityMinted = liquidityA < liquidityB ? liquidityA : liquidityB;\n\t\t}\n\n\t\trequire(liquidityMinted > 0, \"Insufficient liquidity minted\");\n\n\t\t// Update state\n\t\tliquidity[msg.sender] += liquidityMinted;\n\t\ttotalLiquidity += liquidityMinted;\n\t\treserveA += amountA;\n\t\treserveB += amountB;\n\n\t\temit LiquidityAdded(msg.sender, amountA, amountB, liquidityMinted);\n\t}\n\n\t/**\n\t * @notice Remove liquidity from the pool\n\t * @param liquidityAmount Amount of liquidity shares to burn\n\t * @return amountA Amount of token A returned\n\t * @return amountB Amount of token B returned\n\t */\n\tfunction removeLiquidity(\n\t\tuint256 liquidityAmount\n\t) external nonReentrant returns (uint256 amountA, uint256 amountB) {\n\t\trequire(liquidityAmount > 0, \"Amount must be greater than 0\");\n\t\trequire(\n\t\t\tliquidity[msg.sender] >= liquidityAmount,\n\t\t\t\"Insufficient liquidity\"\n\t\t);\n\n\t\t// Calculate amounts to return (proportional to share)\n\t\tamountA = (liquidityAmount * reserveA) / totalLiquidity;\n\t\tamountB = (liquidityAmount * reserveB) / totalLiquidity;\n\n\t\trequire(amountA > 0 && amountB > 0, \"Insufficient liquidity burned\");\n\n\t\t// Update state\n\t\tliquidity[msg.sender] -= liquidityAmount;\n\t\ttotalLiquidity -= liquidityAmount;\n\t\treserveA -= amountA;\n\t\treserveB -= amountB;\n\n\t\t// Transfer tokens back to user\n\t\ttokenA.transfer(msg.sender, amountA);\n\t\ttokenB.transfer(msg.sender, amountB);\n\n\t\temit LiquidityRemoved(msg.sender, amountA, amountB, liquidityAmount);\n\t}\n\n\t/**\n\t * @notice Swap one token for another\n\t * @param tokenIn Address of token to swap in\n\t * @param amountIn Amount of token to swap in\n\t * @return amountOut Amount of token received\n\t */\n\tfunction swap(\n\t\taddress tokenIn,\n\t\tuint256 amountIn\n\t) external nonReentrant returns (uint256 amountOut) {\n\t\trequire(amountIn > 0, \"Amount must be greater than 0\");\n\t\trequire(\n\t\t\ttokenIn == address(tokenA) || tokenIn == address(tokenB),\n\t\t\t\"Invalid token\"\n\t\t);\n\n\t\t// Determine input/output tokens and reserves\n\t\tbool isTokenA = tokenIn == address(tokenA);\n\t\t(IERC20 tokenInContract, IERC20 tokenOutContract) = isTokenA\n\t\t\t? (tokenA, tokenB)\n\t\t\t: (tokenB, tokenA);\n\t\t(uint256 reserveIn, uint256 reserveOut) = isTokenA\n\t\t\t? (reserveA, reserveB)\n\t\t\t: (reserveB, reserveA);\n\n\t\t// Transfer input token from user\n\t\ttokenInContract.transferFrom(msg.sender, address(this), amountIn);\n\n\t\t// Calculate output amount with fee\n\t\t// Formula: amountOut = (amountIn * reserveOut) / (reserveIn + amountIn)\n\t\t// With 0.3% fee: amountIn = amountIn * (1 - 0.003) = amountIn * 997/1000\n\t\tuint256 amountInWithFee = amountIn * (FEE_DENOMINATOR - FEE_NUMERATOR);\n\t\tuint256 numerator = amountInWithFee * reserveOut;\n\t\tuint256 denominator = (reserveIn * FEE_DENOMINATOR) + amountInWithFee;\n\t\tamountOut = numerator / denominator;\n\n\t\trequire(amountOut > 0, \"Insufficient output amount\");\n\t\trequire(amountOut < reserveOut, \"Insufficient liquidity\");\n\n\t\t// Update reserves\n\t\tif (isTokenA) {\n\t\t\treserveA += amountIn;\n\t\t\treserveB -= amountOut;\n\t\t} else {\n\t\t\treserveB += amountIn;\n\t\t\treserveA -= amountOut;\n\t\t}\n\n\t\t// Transfer output token to user\n\t\ttokenOutContract.transfer(msg.sender, amountOut);\n\n\t\temit Swap(msg.sender, tokenIn, amountIn, amountOut);\n\t}\n\n\t/**\n\t * @notice Calculate swap output amount (view function)\n\t * @param tokenIn Address of token to swap in\n\t * @param amountIn Amount of token to swap in\n\t * @return amountOut Estimated amount of token to receive\n\t */\n\tfunction getSwapAmount(\n\t\taddress tokenIn,\n\t\tuint256 amountIn\n\t) external view returns (uint256 amountOut) {\n\t\trequire(amountIn > 0, \"Amount must be greater than 0\");\n\t\trequire(\n\t\t\ttokenIn == address(tokenA) || tokenIn == address(tokenB),\n\t\t\t\"Invalid token\"\n\t\t);\n\n\t\t// Determine reserves\n\t\tbool isTokenA = tokenIn == address(tokenA);\n\t\t(uint256 reserveIn, uint256 reserveOut) = isTokenA\n\t\t\t? (reserveA, reserveB)\n\t\t\t: (reserveB, reserveA);\n\n\t\t// Calculate output with fee\n\t\tuint256 amountInWithFee = amountIn * (FEE_DENOMINATOR - FEE_NUMERATOR);\n\t\tuint256 numerator = amountInWithFee * reserveOut;\n\t\tuint256 denominator = (reserveIn * FEE_DENOMINATOR) + amountInWithFee;\n\t\tamountOut = numerator / denominator;\n\t}\n\n\t/**\n\t * @notice Get current pool state\n\t * @return _reserveA Reserve of token A\n\t * @return _reserveB Reserve of token B\n\t * @return _totalLiquidity Total liquidity shares\n\t */\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (uint256 _reserveA, uint256 _reserveB, uint256 _totalLiquidity)\n\t{\n\t\treturn (reserveA, reserveB, totalLiquidity);\n\t}\n\n\t/**\n\t * @notice Get user's liquidity position\n\t * @param user Address to check\n\t * @return liquidityAmount User's liquidity shares\n\t * @return sharePercentage User's percentage of pool (in basis points, e.g., 1000 = 10%)\n\t */\n\tfunction getUserLiquidity(\n\t\taddress user\n\t) external view returns (uint256 liquidityAmount, uint256 sharePercentage) {\n\t\tliquidityAmount = liquidity[user];\n\t\tsharePercentage = totalLiquidity > 0\n\t\t\t? (liquidityAmount * 10000) / totalLiquidity\n\t\t\t: 0;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}